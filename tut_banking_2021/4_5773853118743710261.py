#!/usr/bin/env python3.8
import os, re, sys
from itertools import permutations, combinations

def printf(format, *args):
        sys.stdout.write(format % args)

def deposit(acc_num, amount):
    account_balances[acc_num] += amount

def withdrawal(acc_num, amount):
    if amount <= account_balances[acc_num]:
        account_balances[acc_num] -= amount;

def transfer(src, dest, amount):
    if amount <= account_balances[src]:
        account_balances[src] -= amount
        account_balances[dest] += amount

def main():
    global account_balances;
    datadir = "data"; #directory in which data files can be found
    outdir = "out";   #directory to place output files in
    argmin = 1;       #minimum number of arguments
    argmax = 10;      #maximum number of arguments

    if len(sys.argv) == 1:
        printf("Usage: %s (permute|nopermute) [<min args> <max args>]\n",
            sys.argv[0]);
        exit(1);
    elif len(sys.argv) > 3:
        argmin = min(int(sys.argv[2]), int(sys.argv[3])); 
        argmax = max(int(sys.argv[2]), int(sys.argv[3])); 
        if argmin < 1:
            argmin = 1;
        if argmax > 10:
            argmax = 10;

    #make a clean rebuild
    exstatus = os.system("make clean");
    if exstatus != 0:
        printf("\n\033[22;31mCould not clean successfully.\033[0m\n");
        printf("\033[22;33mYou might want to replace `rm ${EXECUTABLE}` " + \
                "by `rm -f ${EXECUTABLE}` in your Makefile.\033[0m\n");
        exit(1);
    exstatus = os.system("make");
    if exstatus != 0:
        print("\n\033[22;31mCould not compile successfully.\033[0m");
        exit(1);
    printf("\n");

    #removing old output files:
    os.system("rm -rf out");
    os.makedirs(outdir, exist_ok=True);

    #expected format in which transactions will be reported
    error_fmt = "(Something bad happened, no list)";
    error_re = re.compile(error_fmt);
    #expected format in which transactions will be reported
    trans_fmt = "User (\d+), Acc (\d+) Balance (\d+\.\d+), ";
    trans_fmt += "(Transfer|Deposit|Withdraw) (\d+\.\d+)( to Acc (\d+))?";
    trans_re = re.compile(trans_fmt);
    #expected format for summaries of account balances
    sum_fmt = "Account (\d+) balance after completion of transaction batch: ";
    sum_fmt += "(\d+\.\d+)";
    sum_re = re.compile(sum_fmt);

    #get a list of files from the data directory
    files = list();
    for f in os.scandir(datadir + "/"): 
        fsplit = f.name.split(".");
        if (len(fsplit) > 1 and fsplit[1] == "txt"):
            files.append(datadir + "/" + f.name);

    #test the binary with 1 to 10 arguments
    for maxargs in range(argmin, argmax):
        filecombos = combinations(files, maxargs);

        combo_num = 0;
        for fcombo in filecombos:

            #loop through all permutations of the 10 data files and use them as
            #arguments to call ./my_executable with
            fileperms = list(permutations(list(fcombo)));
            case_num = 0;
            for args in fileperms:
                #file to redirect stderr to
                errfilename = "./" + outdir + "/arg" + str(maxargs) + \
                        "-combo" + str(combo_num) + \
                        "-perm" + str(case_num) + ".err";
                #file to redirect stdout to
                outfilename = "./" + outdir + "/arg" + str(maxargs) + \
                        "-combo" + str(combo_num) + \
                        "-perm" + str(case_num) + ".out";
                command = "./my_executable " + str(len(args)) + " " + \
                        " ".join(args);
                commandout = " 2> " + errfilename;
                commandout += " 1>> " + outfilename;
                case_num += 1;
                printf("Validating %-30s ...    ", outfilename);

                outfile = open(outfilename, "w");
                outfile.write("# Output generated by:\n# " + command + \
                        "\n\n");
                outfile.close();
                os.system(command + commandout);

                #report error in case anything was redirected to stderr
                errfile = open(errfilename, "r");
                errlines = errfile.readlines();
                if len(errlines) > 0:
                    printf("[\033[22;31mfailure\033[0m]\n  " + \
                            "\033[22;33mNon-empty output to stderr.\n  " + \
                            "See %s\033[0m\n",
                            errfilename);

                #otherwise check balances
                else:
                    outfile = open(outfilename, "r");
                    outlines = outfile.readlines();
                    account_balances = [0] * 10;
                    linenum = 0;
                    success = True;

                    #perform transactions line by line
                    for line in outlines:

                        linenum += 1;
                        trans_match = trans_re.match(line);
                        sum_match = sum_re.match(line);
                        error_match = error_re.match(line);

                        #check whether any error messages were printed
                        if error_match != None: 
                            printf("[\033[22;31mfailure\033[0m]\n  " + \
                                    "\033[22;33m" + \
                                    "line %d of file %s\n  ",
                                    linenum, outfilename);
                            printf("Error: %s \033[0m\n",
                                    error_match.group(0));
                            success = False;
                            break;
                        
                        elif trans_match != None: 
                            #get variables from regex groups
                            #user = int(trans_match.group(1));
                            acc = int(trans_match.group(2));
                            balance = float(trans_match.group(3));
                            transtype = trans_match.group(4);
                            amount = float(trans_match.group(5));
                            dest = trans_match.group(7);

                            #debugging output:
                            #print(trans_match.group(0));
                            #print("user:", user, "acc:", acc, "balance:",
                            #       balance, "transtype:", transtype,
                            #       "amount:", amount, "dest:", dest);

                            #report error, if balance is not as expected
                            if balance != account_balances[acc]:
                                printf("[\033[22;31mfailure\033[0m]\n  " + \
                                        "\033[22;33m" + \
                                        "line %d of file %s\n  ",
                                        linenum, outfilename);
                                printf("expected %f but got " + \
                                        "%f\033[0m\n", account_balances[acc],
                                        balance);
                                success = False;
                                break;
                            #otherwise perform transaction
                            elif transtype == "Transfer":
                                if dest == None:
                                    printf("\033[22;31mFATAL ERROR:" + \
                                            "Expected to find destination " + \
                                            "account number. Exiting " + \
                                            "script.\033[0m\n");
                                    exit(1);
                                else:
                                    transfer(acc, int(dest), amount);
                            elif transtype == "Deposit":
                                deposit(acc, amount)
                            elif transtype == "Withdraw":
                                withdrawal(acc, amount)

                        #check balances in summary, if applicable
                        elif sum_match != None:
                            acc = int(sum_match.group(1));
                            balance = float(sum_match.group(2));
                            if balance != account_balances[acc]:
                                printf("[\033[22;31mfailure\033[0m]\n  " + \
                                        "\033[22;33m" + \
                                        "line %d of file %s\n  ",
                                        linenum, outfilename);
                                printf("expected %f but got " + \
                                        "%f\033[0m\n", account_balances[acc],
                                        balance);
                                success = False;
                                break;

                    #if no mismatches were found, we are happy:
                    if success:
                        printf("[\033[22;32msuccess\033[0m]\n");
                    if len(sys.argv) < 2 or sys.argv[1] != "permute":
                        break;
                errfile.close();
                outfile.close();
            combo_num += 1;
    printf("\nThe executed commands can be found at the\n" + \
            "top of the corresponding .out files.\n");
    if len(sys.argv) < 2 or sys.argv[1] != "permute":
        printf("\nExtra: Run `%s permute [<min args> <max args>]`\n" + \
                "to consider permutations of arguments.\n\n" + \
                "Warning: This might easily fill up your hard drive.\n",
                sys.argv[0]);

if __name__ == '__main__':
    main()
